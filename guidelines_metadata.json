["# 4. Operations\n\n## 4.1 Queries\n\nQueries are defined as fields in `type Query`.\n\n### 4.1.1 Query SHOULD be named as noun\n\nQueries return objects, thus quries SHOULD be named as noun. When query returns a single object its name SHOULD be a singular noun. For example, `campaign`. When query returns a list of objects, its name SHOULD be a plural noun. For example, `campaigns`.", "When single object represents multiple values or corresponding noun has only plural form query name MAY be a noun in plural. For example, `settings`, `statistics`, `savings`.\n\n### 4.1.2 The common type \"FilterInput\" SHOULD be used for filtering\n\n`FilterInput` type provides a universal way to specify a field, an operation and values for filtering.\nFilters parameter SHOULD be named `filters`.\n\nExample:\n```graphql\ntype Query {\n  bankAccounts(filters: [FilterInput!]): BankAccountList!\n}\n```", "### 4.1.3 Parameters representing matching entity properties MAY be used for filtering when query has limited filtering capabilities\n\nWhen query implements filtering by matching only few entity properties they MAY be represented by individual parameters of matching type.\n\nExample:\n```graphql\ntype Query {\n  bankAccounts(status: BankAccountStatus, ownerId: ID): BankAccountList!\n}\n```\n\n### 4.1.4 Parameter for search string SHOULD be named \"search\"", "If query has a parameter for a search string it SHOULD be named `search`.\n\nExample:\n```graphql\ntype Query {\n  customers(search: String): CustomerList!\n}\n```\n\n### 4.1.5 The common type \"SortInput\" MUST be used for sorting\n\n`SortInput` type provides a universal way to specify a field and an order for sorting.\nSorting parameter SHOULD be named `sortBy`.\n\nExample:\n```graphql\ntype Query {\n  bankAccounts(sortBy: [SortInput!]): BankAccountList!\n}\n```", "### 4.1.6 The common type \"PaginationInput\" MUST be used for pagination\n\n`PaginationInput` type provides a universal way to specify an offset and a limit for pagination.\nPagination parameter SHOULD be named `pagination`.\n\nExample:\n```graphql\ntype Query {\n  bankAccounts(pagination: PaginationInput): BankAccountList!\n}\n```\n\n### 4.1.7 Filtering, sorting and pagination parameters MUST be defined in this order", "When querying entities first filtering is applied, then sorting and then pagination. This defines natural order of these parameters in the query.\n\nExamples:\n```graphql\ntype Query {\n  bankAccounts(\n    filters: [FilterInput!],\n    sortBy: [SortInput!],\n    pagination: PaginationInput): BankAccountList!\n}\n```\n\n```graphql\ntype Query {\n  bankAccounts(\n    status: BankAccountStatus, ownerId: ID, search: String,\n    sortBy: [SortInput!],\n    pagination: PaginationInput): BankAccountList!\n}\n```", "### 4.1.8 When module doesn't need a query it SHOULD define a \"dummy\" query\n\nGraphQL pipeline requires a query to be defined in the module. In order to minimise such dummy queries in the composite schema an identical query SHOULD be used in all such modules. When module schemas are merged into the single composite schema GraphQL merges identical query definitions into single one.\n\nFollowing dummy query SHOULD be used:\n```graphql\ntype Query {\n  dummy: String\n}\n```\n\n## 4.2 Mutations", "## 4.2 Mutations\n\nMutations are defined as fields in `type Mutation`.\n\n### 4.2.1 Mutation SHOULD be named as verb\n\nMutation name SHOULD be in the form `<verb><entity>` or `<verb><entity><field>`. `verb` MAY be `create`, `update`, `delete`, `set`, `upsert`, `add`, `remove`, etc.\n\nFor example, `createBankAccount`, `setBankAccountStatus`.\n\n### 4.2.2 Mutation SHOULD return a resulting entity it created or mutated\n\nWhen mutation creates or updates an entity it SHOULD return a resulting entity.", "Example:\n```graphql\ntype Mutation {\n  createBankAccount(bankAccount: CreateBankAccountInput!): BankAccount!\n  updateBankAccount(id: ID!, bankAccount: UpdateBankAccountInput!): BankAccount!\n}\n```\n\n### 4.2.3 Mutation SHOULD return Void when it yields no result\n\nWhen mutaton inherently doesn't return a value, for example, when underlying API returns no content, mutation SHOULD return custom scalar `Void`.", "GraphQL does not allow mutation to return nothing because technically mutation is a field and a field must have its type.\n\nExample:\n```graphql\ntype Mutation {\n  setBankAccountStatus(id: ID!, status: BankAccountStatus!): Void\n  deleteBankAccount(id: ID!): Void\n}\n```\n\n### 4.2.4 Mutation MAY return entity id\n\nWhen returning full entity is not feasible or returning `Void` is not suitable, mutation MAY return identifier of affected entity.", "### 4.2.5 Custom type \"Upload\" MUST be used in mutations that upload file\n\nCustom type `Upload` provides support for file upload and MUST be used when file upload is needed. Custom resolver is needed for file upload. Returned type with uploaded file data is specific to a business domain.\n\nExample:\n```graphql\ntype Mutation {\n  uploadTransactionsData(file: Upload!): TransactionsFile!\n}\n```\n\n## 4.3 Subscriptions", "## 4.3 Subscriptions\n\nSubscription allows client to get an event stream as a result of a particular operation. Upon execution of GraphQL subscription client establishes a channel through which events are delivered.\nSubscriptions are defined as fields in `type Subscription`.\n\n### 4.3.1 Architects MUST be consulted with before introducing new subscription\n\nNew subscriptions are rarely introduced in Adform GraphQL schema thus architects MUST be contacted before doing so.", "### 4.3.2 Subscription MUST be used to get results of asynchronous operation\n\nInstead of implementing query for polling results or other similar approach a GraphQL subscription MUST be used.\n\n### 4.3.3 Operations that produce events to \"entityEvent\" subscription MUST have parameter named \"subscriptionId\"", "Subscription `entityEvent` is most versatile and most widely used in Adform GraphQL schema. It is used to observe status of asynchronous long running entity based operations, such as creation or update of entities, including bulk updates, import, export.", "Subscription `entityEvent` accepts parameter `operationEventId` that uniquely identifies subscription and is used for routing events to a particular client. Operations that produce entity events MUST have corresponding parameter that accepts the same subscription id and that parameter MUST be named `subscriptionId`, as this name better represents its meaning.\n\nParameter `subscriptionId` MUST be the first one in a mutation or a query.", "Example:\n```graphql\ntype Mutation {\n  validateBankAccount(subscriptionId: ID!, id: ID!): ID!\n}\n```\n\n## 4.4 Asynchronous operations\n\nWhen operation by design takes considerable amount of time to complete it must be implemented as an asynchronous operation. Examples of such operations are import, export, creation of entities when result cannot be provided in real time, and so on.\n\n### 4.4.1 Status and outcome of asynchronous operation MUST be provided via subscription", "Asynchronous operation MUST accept parameter `subscriptionId` of type `ID`.\n\nAsynchronous operation MUST provide its status and/or outcome as event(s) published to subscription stream with given `subscriptionId`.\n\nDescription of asynchronous operation in the schema MUST indicate which subscription it publishes events to.", "# Modules in the service catalog\n\nIt is crucial to provide ownership information for modules. Every module has to be registered as a service in [SIT](https://sit.adform.zone/services/services/all) and a correct owning team has to be indicated.\n\nBelow are the guidelines for registering a service for a module.\n\n## Project specific modules\n\nModules in different AAP projects have different requirements for corresponding service in SIT. These requirements are listed below.", "### Schema Module Catalog module\n\nA service for a module must be registered in SIT under the product/scope that represents module's domain area.\n\nService category must be `GraphQL Schema Module`, technology must be `GraphQL`. Service title must derive from module name in Schema Module Catalog and end with `-SCHEMA-MODULE`.\n\nExample service titles: `CAMPAIGNS-SCHEMA-MODULE`, `DIRECT-LINE-ITEM-FEES-INPUT-MODE-SCHEMA-MODULE`.\n\n### Schema Module Catalog relations module", "### Schema Module Catalog relations module\n\nA service must be registered in SIT for module under the product/scope that represents domain area of the type that the module extends with relation.\n\nService category must be `GraphQL Schema Module`, technology must be `GraphQL`. Service title must derive from module name in Schema Module Catalog and end with `-RELATIONS-MODULE`.\n\nExample service titles: `RTB-LINE-ITEM-RELATIONS-MODULE`, `AGENCY-ENTITY-LIST-RELATIONS-MODULE`.", "### Bulk Service module\n\nA service for a module must be registered in SIT under the product/scope that represents module's domain area.\n\nService category must be `GraphQL Bulk Module`, technology must be `Node.JS`. Service title must derive from module name in Bulk Service and end with `-BULK-MODULE`.\n\nExample service titles: `ORDER-BULK-MODULE`, `RTB-TARGETING-LIST-DOMAINS-REMOVE-BULK-MODULE`.\n\n### Listener Platform module", "### Listener Platform module\n\nA service for a module must be registered in SIT under the product/scope that represents module's domain area.\n\nService category must be `AAP Listener Module`, technology must be `Node.JS`. Service title must derive from module name in Listener Platform and end with `-LISTENER-MODULE`.\n\nExample service titles: `CIAM-NOTIFICATION-LISTENER-MODULE`, `ENTITY-EXPORT-NOTIFICATION-LISTENER-MODULE`.\n\n### AAP Middleware Server module", "### AAP Middleware Server module\n\nA service for a module must be registered in SIT under `AAP-MIDDLEWARE-SERVER` product/scope.\n\nService category must be `GraphQL Schema Module`, technology must be `GraphQL`. Service title must derive from module name in AAP Middleware Server and end with `-SCHEMA-MODULE`.\n\nExample service titles: `AUTH-OPERATIONS-SCHEMA-MODULE`, `SUBSCRIPTIONS-SCHEMA-MODULE`.\n\n## URLs and dependencies", "## URLs and dependencies\n\nURL to module's directory in git respository in its primary branch must be provided for a service in SIT. Its kind must be `Code`.\n\nURL to the latest module's external review page must be provided for a service in SIT. Its kind must be `Other`, title must be `Review`.\n\nA project the module is a part of must be listed as \"depends on\" for module's service in SIT.", "# 3. Types\n\n## 3.1 Scalars\n\nScalars typically represent primitive types and can be used both in operation responses and in operation parameters. They are defined with `scalar` keyword.\n\n### 3.1.1 Built-in scalars MUST be used\n\n[Built-in scalar types](https://spec.graphql.org/October2021/#sec-Scalars) MUST be used for the purpose they are defined for. Custom scalars SHOULD NOT be defined if they repeat functionality of the built-in scalars.\n\n### 3.1.2 Existing custom scalars MUST be used", "### 3.1.2 Existing custom scalars MUST be used\n\nThere are common custom scalar and object types defined in [AAP library](https://gitz.adform.com/AAP/AAP-libs/tree/develop/packages/aap-types).", "Following custom scalars MUST be used when functionality they provide is needed:\n- `Any` - represents any primitive or object value.\n- `BigInt` - represents integer value between -(2^53)+1 and 2^53-1.\n- `CurrencyCode` - represents three letters currency code according to ISO 4217\n- `Decimal` - represents decimal value where digits after decimal point are preserved. Typical usage: monetary values, percentage and rate values entered by user.", "- `Date` - represents date and time with offset. Typical usage: auditing fields such as `createdAt`, `lastUpdatedAt`.\n- `LocalDate` - represents date without time and without offset. Typical usage: period dates of business entities in local time.\n- `LocalDateTime` - represents date and time without offset. Typical usage: period dates with time of business entities in local time.", "- `Void` - indicates that operation returns no value. It is useful for mutations based on REST API endpoints that return \"No content\". Its value is serialized as `null`.", "Following custom scalars MUST NOT be used:\n- `JSONType` - `Any` SHOULD be used instead\n- `NonNegativeFloat` - `Float` SHOULD be used instead\n- `EmailAddress` - rarely used, its usefulness is doubtful\n- `ObjectId` - not used, its usefulness is doubtful\n- `URL` - rarely used, its usefulness is doubtful\n- `UUID` - `ID` SHOULD be used instead.\n\n### 3.1.3 Custom scalar \"Any\" SHOULD be avoided", "### 3.1.3 Custom scalar \"Any\" SHOULD be avoided\n\nWe strive to have a strongly typed GraphQL schema. However, sometimes due to underlying implementation it is too difficult to express a model in strongly typed manner. Then usage of `Any` type may be justified, but it SHOULD be avoided as much as possible.\n\nBelow are the examples of justified usage of `Any` type.", "Generic value in notification property:\n```graphql\ntype NotificationProperty {\n  name: String\n  type: NotificationPropertyType\n  value: Any\n}\n```\n\nGeneric value for filter input:\n```graphql\ninput FilterInput {\n  fieldName: String!\n  operation: FilterOperation!\n  values: [Any!]!\n}\n```\n\n### 3.1.4 New custom scalars MAY be introduced", "### 3.1.4 New custom scalars MAY be introduced\n\nNew custom scalar types MAY be introduced, when necessary. Their introduction MUST be aligned with architects. New scalars MUST be introduced in [AAP-libs](https://gitz.adform.com/AAP/AAP-libs) repository. New scalars MUST NOT be introduced in individual schema module.\n\n## 3.2 Enumerations\n\nEnumeration has a name and a set of values. Enumerations are defined with `enum` keyword.\n\n### 3.2.1 Enumeration name MUST be a singular noun", "For example, `ServingMethod`, `BuyingType`.\n\n### 3.2.2 Enumeration name MUST NOT contain word \"enum\"\n\nEnumeration name MUST NOT contain word \"enum\", \"enumeration\" or similar to indicate that the type is enumeration.\n\n### 3.2.3 Enumeration values MUST be strings\n\nEnumeration values MUST NOT be numbers.\n\nExample:\n```graphql\nenum Direction {\n  north\n  east\n  south\n  west\n}\n```\n\n## 3.3 Objects", "## 3.3 Objects\n\nObject types represent models returned by queries, mutations and subscriptions. They are defined with `type` keyword.\n\n### 3.3.1 Object fields SHOULD NOT have parameters\n\nObject fields typically correspond to the fields retrieved by the query and thus SHOULD NOT contain parameters. \n\nRelations (stitched fields) are exception. Stitched fields represent GraphQL queries and thus often have parameters.\n\n## 3.4 Input objects", "## 3.4 Input objects\n\nInput object types are used for operation parameters. They are defined with `input` keyword.\n\n### 3.4.1 Input object names MUST have \"Input\" suffix\n\nFor example, `CampaignInput`.\n\n### 3.4.2 Input objects for mutations MUST NOT include entity id field\n\nWhen necessary, entity id MUST be passed to mutations as a separate parameter.\n\nExample:\n\n```graphql\ninput CampaignInput {\n  name: String!\n}", "type Mutation {\n  updateCampaign(id: ID!, campaign: CampaignInput!): Campaign!\n}\n```\n\n### 3.4.3 Separate input object types MAY be used for create and for update mutations\n\nWhen models for entity create and update mutations are identical, single input object type MAY be used. If models differ, separate input object types SHOULD be used.\n\nExample of single input object:\n\n```graphql\ninput CampaignInput {\n  name: String!\n}", "type Mutation {\n  createCampaign(campaign: CampaignInput!): Campaign!\n  updateCampaign(id: ID!, campaign: CampaignInput!): Campaign!\n}\n```\n\nExample of separate input objects:\n```graphql\ninput CreateCampaignInput {\n  advertiserId: ID!\n  name: String!\n}\n\ninput UpdateCampaignInput {\n  name: String!\n}\n\ntype Mutation {\n  createCampaign(campaign: CreateCampaignInput!): Campaign!\n  updateCampaign(id: ID!, campaign: UpdateCampaignInput!): Campaign!\n}\n```\n\n## 3.5 Lists", "## 3.5 Lists\n\nLists are regular object types designed to represent lists of entities returned by queries.\n\n### 3.5.1 Name of list object type MUST be composed of a single object type name with \"List\" suffix\n\nEntity name in list object type name MUST be in singular. Entity name MAY be in plural when plural form is naturally used to represent a single entity.\n\nFor example, `CampaignList`, `SavingsList` (when single entity type is named `Savings` in plural).", "### 3.5.2 List object type MUST have a field for a list of entities\n\nThe field MUST be named as entity in plural form.\n\nField type MUST be an array of object type representing a single entity. Both array and its elements MUST be non-nullable.\n\nExample:\n```graphql\ntype CampaignList {\n  campaigns: [Campaign!]!\n}\n```\n\n### 3.5.3 List object type SHOULD have a field representing amount of entities\n\nPurpose of such field is to facilitate implementation of pagination or infinite scroll on the client.", "That MAY be a field `totalCount: Int!` that indicates a total amount of entities that can be returned by a query with given filter parameters. Its value MUST NOT depend on sorting or pagination.\n\nOr that MAY be a field `hasMoreItems: Boolean!` that indicates whether there are more entities to be returned by a query with given filter parameters in the next page.\n\nExample:\n```graphql\ntype CampaignList {\n  campaigns: [Campaign!]!\n  totalCount: Int!\n}\n```", "or\n```graphql\ntype CampaignList {\n  campaigns: [Campaign!]!\n  hasMoreItems: Boolean!\n}\n```\n\n### 3.5.4 List object type MAY have other additional fields\n\nThere MAY be other fields in list object type representing useful list properties.\n\nFor example, list of messages for a given user MAY have following additional fields:\n```graphql\nreadCount: Int!\nunreadCount: Int!\n```\n\n## 3.6 Fields", "## 3.6 Fields\n\nFields comprise object types and input object types. Field has a name and a type.\nObject types represent a list of named fields, where each field yields a value of a specific type.\nInput object types define a set of named input fields that can accept input values.\n\n### 3.6.1 Non-null fields MUST be marked accordingly", "By default, fields are nullable. Non-null fields are marked with exclamation mark `!`. See [specification](https://spec.graphql.org/October2021/#sec-Non-Null) for more details.\n\nNon-null MUST be marked with `!` as much as possible. This allows clients to understand business entities better and to consume GraphQL schema more efficiently.", "Examples:\n```graphql\ntype BankAccount {\n  iban: ID!       # value cannot be null\n  cards: [Card!]  # value can be null, value can be an empty array, array cannot have null values\n  transactions: [Transaction!]! # value cannot be null, value can be an empty array, array cannot have null values\n}\n```\n\n### 3.6.2 Fields that represent entity identifier MUST be of `ID` type", "Fields that represent entity identifier MUST be of `ID` type. It is not important whether underlying id is represented by an integer, UUID or other format.", "Note that internally `ID` values are represented as strings, they are serialized to JSON as strings. Because of that, underlying JVM based APIs that use integer identifiers produce an error, because JVM parsing is strict and by default it is unable to parse strings to integers. Such problem does not exist with .Net based APIs. Due to this reason entity identifiers in certain schema modules based on JVM APIs need to be converted to integer in pre-resolvers.", "Fields representing identifiers of entities in external (non-Adform) systems, when such entities are not represented in Adform GraphQL schema, MAY use other types. For example, field `adGapId` for line items, which contains an identifier for third-party system.\n\n### 3.6.3 Boolean fields MUST NOT have \"is\", \"has\", \"does\" or similar prefix", "It is for consistency with [API guidelines](https://gitz.adform.com/pages/ADP/api-guidelines/#/payload?id=_67-boolean-must-be-represented-as-json-boolean-data-type-).\n\nFor example, `active`, `verified`.\n\nPrefix MAY be used when lack of such would make field name unclear. For example, `hasSubdomains`.\n\n## 3.7 Interfaces\n\nInterface can only be used as output type. It cannot be used as parameter for query or mutation.\n\n### 3.7.1 Interfaces SHOULD be used with caution", "### 3.7.1 Interfaces SHOULD be used with caution\n\nIn Adform interfaces are not widely used. If there is a need or an idea for interface usage, it MUST be discussed and agreed with architects in advance.\n\n## 3.8 Unions\n\nUnion can only be used as output type. It cannot be used as parameter for query or mutation.\n\n### 3.8.1 Unions SHOULD be used with caution", "### 3.8.1 Unions SHOULD be used with caution\n\nIn Adform unions are not widely used. If there is a need or an idea for union usage, it MUST be discussed and agreed with architects in advance.\n\n## 3.9 Directives", "## 3.9 Directives\n\nDirectives MAY be used for additional functionality. Directives can be of two types:\n- schema (or type system) directives - they are applied in schema definition. For example, `@deprecated`, `@cacheControl`.\n- query (or executable) directives - they are used by clients and are applied in queries. For example, `@include`, `@skip`.\n\n### 3.9.1 Custom directives SHOULD be introduced with caution", "In Adform custom directives are not widely used. If there is a need or an idea for a custom directive, it MUST be discussed and agreed with architects in advance.\n\n### 3.9.2 Deprecated schema elements MUST be marked with @deprecated directive\n\nOperations, their parameters, fields, enum values that should not be used anymore MUST be marked with `@deprecated` directive providing the reason for deprecation and alternatives to use.\n\n## 3.10 Errors", "## 3.10 Errors\n\nCurrently Adform returns errors in a separate untyped field `errors` which is not represented in GraphQL schema. This implementation is according to GraphQL specification and industry standarts, but this may be changed in the future.\n\n### 3.10.1 Types for errors MUST NOT be defined in the schema\n\nCurrently errors are returned in untyped manner. If there is a need for typed errors, it MUST be discussed and agreed with architects in advance.", "# Review process\n\nGraphQL schema review process is established in order to ensure that these guidelines are properly applied.\n\nGraphQL schema MUST be designed according to the guidelines. This applies to all types of schema modules that are part of the composite schema exposed by Middleware Server. They include (but are not limited to) modules in Schema Module Catalog, Bulk Service, Recents Service, Favorites Service and so on. Typically schema is defined in `*.gql` files.\n\n## Terms", "## Terms\n\n- Word *architects* below and in the entire guidelines means *domain architect responsible for GraphQL and / or Web platform group solution architect*.\n\n- Phrase *must be discussed and agreed with architects* implies that an evidence of such agreement has to be linked to a pull request. Such evidence can be a thread in a public Slack channel, a comment in a pull request, a screenshot of an email. It is preferrable that the evidence contains a reasoning behind the decision.", "## Preliminary review\n\nSchema changes SHOULD be preliminary reviewed early in design phase by architects and / or external reviewers. This is to validate design decisions and to reduce risk of changes in the final phase of development.\n\n## Developer\n\n1. Developer MUST run automated schema validation tool and fix validation errors.  \n    1.1. GHA build [step](https://gitz.adform.com/AAP/AAP-schema-module-catalog/blob/v11.0.17/.github/workflows/ci.yaml#L106).", "1.2. Find more info in [AAP documentation](https://gitz.adform.com/pages/AAP/AAP-Documentation/backend-development/schema-module-validation).\n\n2. Developer MUST follow these guidelines when developing new or changing existing schema.  \n\n3. Developer MUST tag relevant reviewers in a pull request and provide a link to a pull request in `#aap` Slack channel.  \n    3.1. Pull request description MUST contain a link to a Jira item for external review.", "3.2. Pull request description MUST contain a link to a review Confluence page.  \n\n    3.3. Schema changes MUST be approved by module owners. When changes are made by owning team, a team member other than the author of the changes MUST approve them. This is considered a part of the internal schema review and MUST be done prior to the external schema review. Ownership of modules is defined in [SIT](https://sit.adform.zone/services/services/all).", "3.4. Schema MUST be reviewed by external reviewer.\n    External reviewers are listed in the [GraphQL review calendar](https://adform.atlassian.net/wiki/spaces/ADP/pages/2709849634/GraphQL+Review+Calendar). Steps for external GraphQL review are described in the [quick guide](https://adform.atlassian.net/wiki/spaces/ADP/pages/2719515023/Quick+Guide+To+How+To+Use+The+GraphQL+Review+List).  \n\n    <a id=\"external-review-is-mandatory\"></a>\n    3.4.1. External review is mandatory:", "- when new type, operation or module is added  \n    - when existing type, operation or module is renamed.\n\n    3.4.2. External review is not mandatory:  \n\n    - when fields are changed in existing types  \n    - when parameters are changed in existing operations  \n    - when types, operations or modules are removed.", "3.5. [AAP team](https://gitz.adform.com/orgs/AAP/teams/team-aap-be/members), as owners of [AAP projects](https://gitz.adform.com/AAP), is responsible for final pull request review and merge. AAP team performs their review after internal and external reviews are done. AAP team provides comments in the pull request.", "3.6. In certain cases the changes MAY be merged to main branch before external review is done. Such changes MUST NOT affect current functionality. Then proper external review MUST be performed before the changes are publicly released.  \n\n    3.6.1. Example of such case is a development of a new feature when a pull request with changes is being kept for a long time and that causes inconveniences.", "3.6.2. Content of such pull request MUST be preliminarily reviewed externally and / or by architects and other interested parties, as part of initial design meetings or as a separate activity.  \n\n    3.6.3. Such merge MUST be approved by architects.  \n\n    3.7. If agreement cannot be reached between developer and reviewer(s), architects are responsible to make a final decision.", "4. Developer MUST fix the schema according to reviewer\u2019s comments, if there are any.  \n    4.1. If for any reasons it is decided to release the changes with issues unfixed, such issues and reasons MUST be listed on schema review Confluence page.\n\n## Reviewer", "## Reviewer\n\n1. When asked by a developer, reviewer MUST review GraphQL schema changes and check if they are compliant with the guidelines. Review feedback is provided on review Confluence page under [GraphQL Review List](https://adform.atlassian.net/wiki/spaces/ADP/pages/2709849563/GraphQL+Review+List). Review page is created from [GraphQL schema review page template](https://adform.atlassian.net/wiki/spaces/ADP/pages/2719453508/GraphQL+schema+review+page+template).", "2. Reviewer SHOULD include [Andrej Chocianovi\u010d](https://adform.atlassian.net/wiki/people/557058:c733121d-a806-4eb2-9e04-4947e72c67ec) as a consultant for the review.", "# 1. Module\n\nA schema module is a component that defines a portion of the schema specific to a business domain. It consists of:\n- GraphQL schema with its types and operations (queries, mutations, subscriptions), typically in a `.gql` file;\n- configuration file;\n- resolvers.\n\nSchema module has an owner (owning team).\n\n#### Module types in Schema Module Catalog", "#### Module types in Schema Module Catalog\n\nSchema modules in Schema Module Catalog can be of the following types:\n- REST module - implements a GraphQL schema over a REST API employing REST resolvers provided by SMC.\n- Relation module - provides relations between existing types in the schema.\n- Bespoke module - differently from REST modules implements custom resolvers.\n- Remote module - encapsulates a schema implemented in other service, contains a copy of that remote schema.", "#### Design principles\n\nModule schema should be designed with business domain and GraphQL in mind.\nMaking the module schema just a copy of underlying API may lead to an inconsistent schema.\nAPI can be using names that do not properly incorporate into the composite schema.\nOr mapping endpoint semantics to GraphQL operation directly may produce a query or mutation that doesn't look right in GraphQL schema context.\n\n#### REST modules", "#### REST modules\n\nREST modules should implement request deduplication, unless there is a good reason against that. For example see `camaignsModule` in Schema Module Catalog (https://gitz.adform.com/AAP/AAP-schema-module-catalog/tree/develop/src/modules/adform/campaign/campaignsModule).\n\n## 1.1 Module schema MUST be consistent internally\n\nWhen adding new module its elements and their naming MUST be consistent.", "When making changes to existing module their structure and naming MUST be consistent with elements of the existing module schema.\n\n## 1.2 Module schema MUST be consistent within business domain and with business terms\n\nNames, operations in the module MUST be consistent with business terms.\n\n## 1.3 Module schema SHOULD be consistent with names used in underlying API, BEM and DDP", "Types and names in module schema SHOULD be consistent with well designed underlying API, [Business Entity Model](https://gitz.adform.com/adform/business-entity-foundation) and [DDP contracts](https://gitz.adform.com/ddp/contracts).\n\n## 1.4 Module schema MUST be consistent with the entire composite schema", "Naming of types and operations MUST follow the same pattern as in other well designed modules. Well designed modules are those that have passed external [review](https://adform.atlassian.net/wiki/spaces/ADP/pages/2709882584/DONE+-+GraphQL+Review).\n\n## 1.5 Module schema MUST NOT expose API specifics\n\nHTTP aspects of REST APIs are not part of GraphQL and thus they MUST be avoided.", "They include:\n- HTTP status code\n- a parameter for `Return-Total-Count` header\n- field for `ETag` header and parameters for related `If-Match` and similar headers.\n\nNon-success HTTP status codes are automatically handled by GraphQL pipeline and are transformed into `errors` field in GraphQL response, see [3.10](section03-types.md#_310-errors).\n\n## 1.6 A separate module or operations SHOULD NOT be created for core API", "Often single schema module can cover both user and core endpoints of the API. In such cases a separate module or operations SHOULD NOT be created.\n\nSchema Server differentiates between user and core API endpoints based on OAuth token in GraphQL request.\n\n## 1.7 Module SHOULD be put in correct directory in the project\n\nThis applies to Schema Module Catalog, Bulk Service, Listener Platform and other projects. The idea is to reflect SIT products and services in the directory structure.", "Directory structure within projects SHOULD be the following:\n  - level 1: business domain / coreApps / readModel\n    - business domain examples: campaign, advertiser. It SHOULD correspond a SIT product, although existing directory names SHOULD be used and SHOULD NOT be renamed.\n    - \"coreApps\" typically represent functionality to be used across multiple domains. For example, import and export.", "- \"readModel\" typically represents domain entities in enriched form and optimised for querying. For example, modules based on entity pool.\n  - level 2: concrete module within domain area", "## 1.8 Module name\n\n### 1.8.1 Module in Schema Module Catalog MUST have a consistent name\n\nModule name in Schema Module Catalog MUST be in camel case.\n\nModule name in Schema Module Catalog MUST have `Module` suffix.\n\nFor example, `rtbLineItemsForecastingModule`, `adsModule`.\n\n### 1.8.2 Module in Bulk Service MUST have a consistent name", "Module name in Bulk Service (and a matching value of supported types enum) MUST correspond the entity it represents. It MUST be a name of such entity type in the composite schema or derive from it.\n\nFor example, `CampaignRtbSettings`, `OrderStatus`.\n\n## 1.9 Module ownership MUST be indicated in SIT\n\nModule MUST be represented as a service in [SIT](https://sit.adform.zone/services/services/all). Correct owning team MUST be indicated there on product or service level.", "### 1.9.1 SIT service name for Schema Module Catalog module MUST be provided in configuration file\n\nFor modules in Schema Module Catalog service name MUST be provided in module's `configuration.js` file. This service name will be displayed in schema documentation browser.\n\n## 1.10 Platform modules MUST be reused when applicable\n\nAAP backend implements several platform modules for common operations, such as:\n- bulk service\n- entity pool\n- import / export\n- notifications.", "These modules MUST be reused for corresponding functionality instead of creating new ones.", "# 6. Relations\n\nTypes and operations for different business entities are typically implemented in separate schema modules. Often, such entities are related and can be organised into graph where one entity can be accessed from other entity.\n\nConsider types in following example where each type is defined in a separate schema module.\n\nCampaigns module:\n```graphql\ntype Campaign {\n  id: ID!\n  name: String!\n  advertiserId: ID!\n}\n\ntype Query {\n  campaigns(advertiserId: ID!): CampaignList!\n}\n```", "Advertisers module:\n```graphql\ntype Advertiser {\n  id: ID!\n  name: String!\n}\n\ntype Query {\n  advertiser(id: ID!): Advertiser!\n}\n```\n\nIt is possible to define relations between these two types using `extend` keyword.\n\nCampaign relations module:\n```graphql\nextend type Campaign {\n  advertiser: Advertiser!\n}\n```\n\nAdvertiser relations module:\n```graphql\nextend type Advertiser {\n  campaigns: CampaignList!\n}\n```\n\nObject types are extended with additional fields that correspond to queries.", "Then, it is necessary to provide information how to resolve these new fields. This is achieved by schema stitching configuration in relation module's `configuration.js` file.\n\nAs a result, a client is able to write queries such as:\n```graphql\nquery campaignWithAdvertiser {\n  campaign(id: $campaignId) {\n    id\n    name\n    advertiser {\n      id\n      name\n    }\n  }\n}\n```", "Such definition of relations (extended types with relation fields added) and schema stitching configuration are placed in relations modules.\n\n## 6.1 Relation to parent entity SHOULD be added when introducing new type\n\nIt is quite common for a client to want to access direct entity's parent, thus such relations SHOULD be added when a type is introduced. Relations SHOULD be added in a separate relations module.\n\nExample:\n```graphql\nextend type Order {\n  campaign: Campaign!\n}\n```", "## 6.2 Relation to child entities MAY be added when introducing new type\n\nThe need to access entity's child entities is less common. Relation to child entities MAY be added when introducing new type if it is known that client needs such relation.\n\nExample:\n```graphql\nextend type Order {\n  rtbLineItems: RtbLineItemList!\n}\n```\n\n## 6.3 Other kinds of relations MAY be added when introducing new type", "There can be a relation between entities other than parent-child. Such relation MAY be added when a real use case exists.\n\nExample:\n```graphql\nextend type Targeting {\n  country: Country\n}\n```\n\n## 6.4 Relation is an extension of module whose type the relation extends", "Relation field extends a type. Therefore:\n- Relation module MUST be named as type's module with word `Relations` in it. For example, `campaignRelationsModule`.\n- Owner of original type's module MUST own corresponding relation module.\n- In source code relations module MUST be placed in the same directory as the module it extends.", "# How to use this documentation\n\nNumbered pages contain the requirements where each requirement is in its numbered section. These numbered requirements must be implemented by developer and checked by reviewer.\n\nIt is highly recommended to read all requirements while your GraphQL schema is in design stage, before actual development.", "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [BCP 14](https://datatracker.ietf.org/doc/html/bcp14) [[RFC2119](https://datatracker.ietf.org/doc/html/rfc2119)] [[RFC8174](https://datatracker.ietf.org/doc/html/rfc8174)] when, and only when, they appear in all capitals, as shown here.\n\n# GraphQL schema", "# GraphQL schema\n\nAdform composite GraphQL schema provides a contract for Adform business entities, their relations, operations. It consists of multiple domain specific schemas merged into a single one. All types and operations from multiple modules reside in a single namespace.", "The composite schema should be consistent across its schema modules, consistent with [Business Entity Model](https://gitz.adform.com/adform/business-entity-foundation), with [DDP contracts](https://gitz.adform.com/ddp/contracts).", "Entire composite schema is exposed via a single endpoint by [AAP Middleware Server (MS)](https://gitz.adform.com/AAP/AAP-middleware-server). Middleware Server combines schemas from multiple services such as:\n  - [Schema Server](https://gitz.adform.com/AAP/AAP-schema-server)\n  - [Bulk Service](https://gitz.adform.com/AAP/AAP-bulk-service)\n  - [Notification Server](https://gitz.adform.com/AAP/AAP-listener-platform/tree/develop/packages/graphql/aap-notification-server)", "- [Configuration Service](https://gitz.adform.com/AAP/AAP-configuration-service)\n  - [Recents Service](https://gitz.adform.com/AAP/AAP-recents-service)\n  - [Favorites Service](https://gitz.adform.com/AAP/AAP-favorites-service)\n  - [Product Updates Service](https://gitz.adform.com/AAP/AAP-product-updates-service)\n  - and [other](https://gitz.adform.com/AAP/AAP-middleware-server/blob/develop/config/prod.js).", "AAP Schema Server (SS) in its turn merges schema modules from [AAP Schema Module Catalog (SMC)](https://gitz.adform.com/AAP/AAP-schema-module-catalog), where modules implement GraphQL contracts over Adform APIs.\n\nThese guidelines describe requirements and best practices for GraphQL schemas in order to have homogeneous consistent composite GraphQL schema for easy and smooth consumption and further development.\n\nThese guidelines apply to all schema modules that are part of the composite schema.", "Visit following resources for learning material about GraphQL:\n  - https://graphql.org/learn\n  - https://www.howtographql.com\n  - https://www.apollographql.com/tutorials\n  - https://principledgraphql.com\n\n# How to contribute", "# How to contribute\n\nInitiate a discussion in a *#graphql-committee* Slack channel or in guidelines github [repository](https://gitz.adform.com/AAP/graphql-guidelines/discussions). After reaching a general consensus create a pull request with proposed changes, share pull request link in the discussion. Pull request must be approved and merged by the architect.", "# 2. Naming conventions\n\n## 2.1 Character casing\n\n### 2.1.1 Names of types MUST be in Pascal case\n\nNames of object, input object, scalar, enum, interface, union MUST be in Pascal case.\n\n### 2.1.2 Names of fields MUST be in camel case\n\nNames of fields of object, input object, interface MUST be in camel case.\n\n### 2.1.3 Names of operations MUST be in camel case\n\nNames of queries, mutations, subscriptions MUST be in camel case.\n\n### 2.1.4 Names of operation parameters MUST be in camel case", "Names of query, mutation and subscription parameters MUST be in camel case.\n\n### 2.1.5 Names of enumeration values MUST be in camel case\n\nEnumeration values MUST be in camel case. This is in order to be consistent with API guidelines for [enums](https://gitz.adform.com/pages/ADP/api-guidelines/#/payload?id=_66-enumerations-must-be-represented-as-strings-) and to avoid mapping of all enum values.\n\n### 2.1.6 Names of directives MUST be in camel case", "Names of directives MUST be in camel case prepended by `@` symbol.\n\n## 2.2 Name elements\n\nRequirements in this section apply to names of all GraphQL schema elements unless indicated otherwise.\n\n### 2.2.1 Abbreviations SHOULD be avoided\n\nAbbreviations in names SHOULD be avoided, unless they are business terms or otherwise widely known and accepted terms.\n\nFor example, full term `ContextualTargeting` should be used instead of `CT`.\n\nExample of accepted abbreviations: `Url`, `Rtb`, `Cpa`, etc.", "### 2.2.2 Acronym / initialism MUST be letter cased as a regular word\n\nAcronym or initialism MUST be letter cased as a regular word. Only the first letter can be in upper case.\n\nFor example, term `RTB` MUST be letter cased as `Rtb` or `rtb`:\n- `RtbLineItem` (type)\n- `rtbLineItems` (query)\n- `RtbDmpMapping` (type)\n- `cpm` (field name)\n\n### 2.2.3 Names MUST NOT contain version\n\nVersions common in APIs, such as `v1` or `v2` MUST NOT be used in names on permanent basis.", "Version specific names MAY be used for limited period of time when implementing breaking changes in multiple phases.\n\n### 2.2.4 Names MUST NOT contain \"dto\"\n\nNames MUST NOT contain `dto` or similar words. Sometimes these are used in underlying APIs. Instead, use business terms consistent across the composite schema.\n\n### 2.2.5 Query names MUST NOT contain \"get\", \"list\"\n\nQuery names MUST NOT contain `get`, `list` or similar verbs.\n\n### 2.2.6 Names SHOULD include unit of measurement", "Field and type names SHOULD express units of measurement for contained value. Typically these SHOULD be implemented as a suffix such as `Ms` (for milliseconds), `Seconds`, `Hours`, `Days`, `Bytes`, `Mb` (for megabytes).\n\nWhen value expresses percentage on 0..1 scale name SHOULD be suffixed with `Rate`. For example, `videoCompletionRate`.\n\nWhen value expresses percentage on 0..100 scale name SHOULD be suffixed with `Percentage`. For example, `deviationPercentage`.", "## 2.3 Consistency and uniqueness\n\nType and operation names MUST represent module's business domain.\n\nCurrently type reusage from different module is not supported. When it is necessary to use type from different module, it SHOULD be copied and named according to a business domain of a target module.\n\n### 2.3.1 If module represents business domain of an entity, entity name SHOULD be used in names as is", "If module represents business domain of an entity, entity name SHOULD be used in names as is. For example, campaigns module representing campaigns business domain SHOULD use `type Campaign`, `query createCampaign` and similar.\n\n### 2.3.2 If type or operation refers to an entity from a different domain its name SHOULD clearly indicate that", "If type or operation refers to an entity from a different domain (i.e., module's business domain doesn't own the entity), its name SHOULD clearly indicate that and MUST NOT interfere with similar entity in original business domain. Typical solution is to use module specific prefix or suffix for such types.\n\nFor example:\n- `Campaign` - represents original business entity in a business domain module\n- `CampaignListItem` - represents campaign read model in a different module.", "# 5. Documentation\n\nGraphQL schema MUST be well documented.\nComments in GraphQL schema are implemented with block strings, i.e., strings wrapped in triple-quotes (`\"\"\"`), that appear immediately before the type, field, operation. These comments appear in schema explorer in GraphQL playground. Documentation supports markdown syntax.\n\n## 5.1 Schema MUST have non-trivial documentation", "Add descriptions that explain meaning and purpose of the type, field, operation. Avoid trivial descriptions that just repeat type or field name. Such trivial descriptions only clutter the source code.\n\n## 5.2 Documentation SHOULD be compact\n\nFor short descriptions triple-quotes and string content SHOULD be on the same line. Otherwise it makes difficult to read the schema in source code.\n\n## 5.3 Documentation MUST be adapted for GraphQL use", "When documentation is copied from underlying API's Swagger it may contain text that makes little sense in GraphQL context. Such text MUST be adapted for GraphQL.\n\nBad example:\n```graphql\ntype BankAccount {\n  \"\"\" Gets or sets bank account name \"\"\"\n  name: String!\n}\n```\n\nIn above example comment that makes sense for .Net property doesn't make sense in GraphQL."]